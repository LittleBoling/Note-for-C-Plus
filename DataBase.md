### 1.事务和ACID特性
概念：事务是满足ACID特性的一组操作，可以通过commit提交一个事务也可以通过Rollback回滚 

<span style="color:red">事务的概念是在InnoDB引擎下，MyISAM引擎不支持事务</span>
<span style="color:blue">MYSQL采用AUTOCOMMIT模式，如果不显式的使用START TRANSACTION来开始一个事务，那么每个查询操作都会被当成一个事务并自动提交</span>
<img src="C:\Users\高杰\Desktop\C++笔记\Note-for-C-Plus\img\ACID.png" style="zoom:50%;" />

#### ACID特性

* 原子性：
* 一致性：数据库在事务执行前后保持一致性，在一致性状态下，所有事务对同一个数据的读取结果是相同的。一致性是目的
* 隔离性：一个事务在执行时对数据库的操作相对于其他事务是不可见的，通过锁来实现
* 持久性：一旦事务提交，其对数据库的修改效果是永久的，既便系统发生崩溃，事务的执行结果也不会消失。

#### ACID关系
* 只有满足一致性，事务的执行结果才是正确的。
* 在串行条件下，事务只要满足了原子性就能满足一致性
* 在并行条件下， 事务需要同时满足原子性和隔离性才能满足一致性
* 持久性是为了应对系统崩溃的情况

### 2.并发一致性问题和事务的隔离级别
#### 事务隔离级别要实际解决的问题
* 丢失修改：指一个事务的修改操作被另一个事务覆盖掉，<span style="color:red">该问题是并发问题</span>。例如：事务T1对和事务T2都对数据进行了修改，但事务T1提交时，事务T2马上被提交，T1的修改就丢失了

* 读脏数据：是指在不同事务下，当前事务可以读到另外事务未提交的数据。例如：T1修改一个数据但未提交， T2随后读取了这个数据。如果T1撤销了这次修改，那么T2读的数据就是脏数据

* 不可重复读：一个事务T1对数据进行多次读操作的同时，另一个事务T2对这部分数据进行了修改并提交生效，这会导致T1前后两次读到的数据不一致（一个事务的两次查询返回了不同的结果）

* 幻影读：幻读也属于不可重复读的情况，事务T1读取了某个范围的数据，事务T2在这个范围重新插入了数据，造成T1前后两次读到的数据不一致

<span style="color:orange">幻读属于INSERT操作，不同于2、3的UPDATE操作</span>
#### 事务隔离级别
只有串行化可以解决全部这三个问题 https://www.jianshu.com/p/271076b79ca8 和 https://zhuanlan.zhihu.com/p/117476959/
* 读未提交（Read uncommitted）：一个事务可以读取另一个事务未提交的问题
* 读提交（Read committed）：事务要等待另一个事务提交后才可读数据， 读提交可解决读脏数据的问题。
* 可重复读：Repeatable read，开始读取数据时不再允许修改操作，可重复读可解决不可重复读的问题，MySQL是这一级别
* 序列化：Serializable，可解决所有问题，效率低下
![](C:\Users\高杰\Desktop\C++笔记\Note-for-C-Plus\img\isolationlevel.png)
隔离级别的具体实现：MySQL的隔离级别是通过锁来实现的。   

进阶问题：MySQL是如何解决幻读的 
行锁和间隙锁的组合 Next-Key 锁实现的
https://blog.csdn.net/u013067756/article/details/90722490

### 3.MySQL锁类型和封锁协议
#### 封锁粒度（行级锁和表级锁）
锁定的数据量越少，发生竞争的可能性就越低，系统的并发成都就越高。但加锁会消耗各种资源，锁的各种操作（获取锁、释放锁和检查锁状态等）都会增加系统开销，锁的粒度越小开销越大。

#### 封锁类型
https://www.jianshu.com/p/358cc1eb40ac

* 行锁/表锁
* 读写锁（可以对表加锁也可以对行数据加锁）
  - 互斥锁：简写为X锁，又称为写锁：同一时间只允许一个事务对某个范围内的数据加X锁，X锁允许读取和更新操作
  - 共享锁：简写为S锁，又称读锁：S锁仅允许读操作，可允许多个事务同时加S锁
* 意向锁：Intention Locks，仅能对表添加意向锁
在存在行级锁和表级锁的情况下，事务A对表中的某一行数据加了锁，数据B想要对整个表加X锁时，就需要一行一行的检查是否有数据加锁，该操作非常耗时，于是意向锁在原来的X、S锁的基础上增加了IX、IS锁，用来表示想在某个数据表的某个行级范围内加锁。
  - 一个事务想要获得某个行的S锁，必须先给表加IS锁 
  - 一个事务想要获得某个行的X锁，必须先给表加IX锁    

任意的IS锁和IX锁都是兼容的，它们并不是真正的锁，多个行级操作的事务可同时对同一个表加IX锁和IS锁
通过引入意向锁，事务A想要给表D加X锁，就需要检查表中是否存在IX/X/IS/S锁，存在任何一个锁都不能加锁

下图为上述几种锁的兼容关系
<img src="C:\Users\高杰\Desktop\C++笔记\Note-for-C-Plus\img\lockconflict.png" style="zoom: 67%;" />
#### 封锁协议 
* 一级封锁协议（对应读未提交）：事务T要修改数据A时必须加写锁，直到T结束时释放； 可解决丢失修改问题，因为不允许有同时两个事务访问同一部分数据，但没有对应的S锁的措施因此无法解决脏数据问题
* 二级封锁协议（对应读提交）：在一级的基础上，要求读数据必须加S锁，读取完之后方可释放S锁（一个事务内有多次读取操作时，就会释放多次）；这样在事务T1对数据进行修改并加上X锁时，事务T2就无法给数据加S锁，因此不能访问，可解决读脏数据问题
* 三级封锁协议（对应可重复度）：在一级的基础上，要求读数据时必须加S锁，待事务结束后释放S锁；由于事务结束后才释放S锁，因此其他事务不能对数据进行修改，所以可同时避免脏读和不可重复读问题
* 四级封锁协议是对三级封锁协议的增强，直接在表上加锁   

<span style="color:blue">两段锁协议，加锁和解锁分成两个阶段进行，使用并发机制构成串行效果，MySQL的InooDB引擎采用两端锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，因此被称为隐式锁定，可以使用语句进行显式锁定</span>
### 4.多版本并发控制
多版本并发控制是InnoDB引擎实现隔离级别的一种具体方式，用于实现读提交和可重复读两种隔离级别，而读未提交总是读取新数据用不到，序列化单纯使用MVCC无法达到
#### 基本原理
1. 利用了多版本的方式，写操作时更新最新的版本快照，而读操作时读旧版本快照
2. MVCC中DELETE/INSERT/UPDRATE会为数据行增加一个版本快照
3. 脏读和不可重复读根本原因都是读取了其他事务未提交的版本，因此MVCC规定只能读取已经提交的快照。一个事务可读取自身未提交的快照
#### 版本号
* 系统版本号，SYS_ID：每开始一个新事务版本号就自动递增
* 事务版本号，TRX_ID:  事务开始时的系统版本号
#### undo_log